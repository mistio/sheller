{"version":3,"file":"xterm-addon-serialize.js","mappings":"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","sources":["webpack://SerializeAddon/webpack/universalModuleDefinition","webpack://SerializeAddon/webpack/startup","webpack://SerializeAddon/./src/SerializeAddon.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SerializeAddon\"] = factory();\n\telse\n\t\troot[\"SerializeAddon\"] = factory();\n})(this, function() {\nreturn ","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = {};\n__webpack_modules__[44](0, __webpack_exports__);\n","/**\n * Copyright (c) 2019 The xterm.js authors. All rights reserved.\n * @license MIT\n *\n * (EXPERIMENTAL) This Addon is still under development\n */\n\nimport { Terminal, ITerminalAddon, IBuffer, IBufferCell } from 'xterm';\n\n\nfunction constrain(value: number, low: number, high: number): number {\n  return Math.max(low, Math.min(value, high));\n}\n\n// TODO: Refine this template class later\nabstract class BaseSerializeHandler {\n  constructor(\n    protected readonly _buffer: IBuffer\n  ) {\n  }\n\n  public serialize(startRow: number, endRow: number): string {\n    // we need two of them to flip between old and new cell\n    const cell1 = this._buffer.getNullCell();\n    const cell2 = this._buffer.getNullCell();\n    let oldCell = cell1;\n\n    this._beforeSerialize(endRow - startRow, startRow, endRow);\n\n    for (let row = startRow; row < endRow; row++) {\n      const line = this._buffer.getLine(row);\n      if (line) {\n        for (let col = 0; col < line.length; col++) {\n          const c = line.getCell(col, oldCell === cell1 ? cell2 : cell1);\n          if (!c) {\n            console.warn(`Can't get cell at row=${row}, col=${col}`);\n            continue;\n          }\n          this._nextCell(c, oldCell, row, col);\n          oldCell = c;\n        }\n      }\n      this._rowEnd(row, row === endRow - 1);\n    }\n\n    this._afterSerialize();\n\n    return this._serializeString();\n  }\n\n  protected _nextCell(cell: IBufferCell, oldCell: IBufferCell, row: number, col: number): void { }\n  protected _rowEnd(row: number, isLastRow: boolean): void { }\n  protected _beforeSerialize(rows: number, startRow: number, endRow: number): void { }\n  protected _afterSerialize(): void { }\n  protected _serializeString(): string { return ''; }\n}\n\nfunction equalFg(cell1: IBufferCell, cell2: IBufferCell): boolean {\n  return cell1.getFgColorMode() === cell2.getFgColorMode()\n    && cell1.getFgColor() === cell2.getFgColor();\n}\n\nfunction equalBg(cell1: IBufferCell, cell2: IBufferCell): boolean {\n  return cell1.getBgColorMode() === cell2.getBgColorMode()\n    && cell1.getBgColor() === cell2.getBgColor();\n}\n\nfunction equalFlags(cell1: IBufferCell, cell2: IBufferCell): boolean {\n  return cell1.isInverse() === cell2.isInverse()\n    && cell1.isBold() === cell2.isBold()\n    && cell1.isUnderline() === cell2.isUnderline()\n    && cell1.isBlink() === cell2.isBlink()\n    && cell1.isInvisible() === cell2.isInvisible()\n    && cell1.isItalic() === cell2.isItalic()\n    && cell1.isDim() === cell2.isDim()\n    && cell1.isStrikethrough() === cell2.isStrikethrough();\n}\n\nclass StringSerializeHandler extends BaseSerializeHandler {\n  private _rowIndex: number = 0;\n  private _allRows: string[] = new Array<string>();\n  private _allRowSeparators: string[] = new Array<string>();\n  private _currentRow: string = '';\n  private _nullCellCount: number = 0;\n\n  // we can see a full colored cell and a null cell that only have background the same style\n  // but the information isn't preserved by null cell itself\n  // so wee need to record it when required.\n  private _cursorStyle: IBufferCell = this._buffer.getNullCell();\n\n  // where exact the cursor styles comes from\n  // because we can't copy the cell directly\n  // so we remember where the content comes from instead\n  private _cursorStyleRow: number = 0;\n  private _cursorStyleCol: number = 0;\n\n  // this is a null cell for reference for checking whether background is empty or not\n  private _backgroundCell: IBufferCell = this._buffer.getNullCell();\n\n  private _firstRow: number = 0;\n  private _lastCursorRow: number = 0;\n  private _lastCursorCol: number = 0;\n  private _lastContentCursorRow: number = 0;\n  private _lastContentCursorCol: number = 0;\n\n  constructor(\n    buffer: IBuffer,\n    private readonly _terminal: Terminal\n  ) {\n    super(buffer);\n  }\n\n  protected _beforeSerialize(rows: number, start: number, end: number): void {\n    this._allRows = new Array<string>(rows);\n    this._lastContentCursorRow = start;\n    this._lastCursorRow = start;\n    this._firstRow = start;\n  }\n\n  private _thisRowLastChar: IBufferCell = this._buffer.getNullCell();\n  private _thisRowLastSecondChar: IBufferCell = this._buffer.getNullCell();\n  private _nextRowFirstChar: IBufferCell = this._buffer.getNullCell();\n  protected _rowEnd(row: number, isLastRow: boolean): void {\n    // if there is colorful empty cell at line end, whe must pad it back, or the the color block will missing\n    if (this._nullCellCount > 0 && !equalBg(this._cursorStyle, this._backgroundCell)) {\n      // use clear right to set background.\n      this._currentRow += `\\u001b[${this._nullCellCount}X`;\n    }\n\n    let rowSeparator = '';\n\n    // handle row separator\n    if (!isLastRow) {\n      // Enable BCE\n      if (row - this._firstRow >= this._terminal.rows) {\n        this._buffer.getLine(this._cursorStyleRow)?.getCell(this._cursorStyleCol, this._backgroundCell);\n      }\n\n      // Fetch current line\n      const currentLine = this._buffer.getLine(row)!;\n      // Fetch next line\n      const nextLine = this._buffer.getLine(row + 1)!;\n\n      if (!nextLine.isWrapped) {\n        // just insert the line break\n        rowSeparator = '\\r\\n';\n        // we sended the enter\n        this._lastCursorRow = row + 1;\n        this._lastCursorCol = 0;\n      } else {\n        rowSeparator = '';\n        const thisRowLastChar = currentLine.getCell(currentLine.length - 1, this._thisRowLastChar)!;\n        const thisRowLastSecondChar = currentLine.getCell(currentLine.length - 2, this._thisRowLastSecondChar)!;\n        const nextRowFirstChar = nextLine.getCell(0, this._nextRowFirstChar)!;\n        const isNextRowFirstCharDoubleWidth = nextRowFirstChar.getWidth() > 1;\n\n        // validate whether this line wrap is ever possible\n        // which mean whether cursor can placed at a overflow position (x === row) naturally\n        let isValid = false;\n\n        if (\n          // you must output character to cause overflow, control sequence can't do this\n          nextRowFirstChar.getChars() &&\n            isNextRowFirstCharDoubleWidth ? this._nullCellCount <= 1 : this._nullCellCount <= 0\n        ) {\n          if (\n            // the last character can't be null,\n            // you can't use control sequence to move cursor to (x === row)\n            (thisRowLastChar.getChars() || thisRowLastChar.getWidth() === 0) &&\n            // change background of the first wrapped cell also affects BCE\n            // so we mark it as invalid to simply the process to determine line separator\n            equalBg(thisRowLastChar, nextRowFirstChar)\n          ) {\n            isValid = true;\n          }\n\n          if (\n            // the second to last character can't be null if the next line starts with CJK,\n            // you can't use control sequence to move cursor to (x === row)\n            isNextRowFirstCharDoubleWidth &&\n            (thisRowLastSecondChar.getChars() || thisRowLastSecondChar.getWidth() === 0) &&\n            // change background of the first wrapped cell also affects BCE\n            // so we mark it as invalid to simply the process to determine line separator\n            equalBg(thisRowLastChar, nextRowFirstChar) &&\n            equalBg(thisRowLastSecondChar, nextRowFirstChar)\n          ) {\n            isValid = true;\n          }\n        }\n\n        if (!isValid) {\n          // force the wrap with magic\n          // insert enough character to force the wrap\n          rowSeparator = '-'.repeat(this._nullCellCount + 1);\n          // move back and erase next line head\n          rowSeparator += '\\u001b[1D\\u001b[1X';\n\n          if (this._nullCellCount > 0) {\n            // do these because we filled the last several null slot, which we shouldn't\n            rowSeparator += '\\u001b[A';\n            rowSeparator += `\\u001b[${currentLine.length - this._nullCellCount}C`;\n            rowSeparator += `\\u001b[${this._nullCellCount}X`;\n            rowSeparator += `\\u001b[${currentLine.length - this._nullCellCount}D`;\n            rowSeparator += '\\u001b[B';\n          }\n\n          // This is content and need the be serialized even it is invisible.\n          // without this, wrap will be missing from outputs.\n          this._lastContentCursorRow = row + 1;\n          this._lastContentCursorCol = 0;\n\n          // force commit the cursor position\n          this._lastCursorRow = row + 1;\n          this._lastCursorCol = 0;\n        }\n      }\n    }\n\n    this._allRows[this._rowIndex] = this._currentRow;\n    this._allRowSeparators[this._rowIndex++] = rowSeparator;\n    this._currentRow = '';\n    this._nullCellCount = 0;\n  }\n\n  private _diffStyle(cell: IBufferCell, oldCell: IBufferCell): number[] {\n    const sgrSeq: number[] = [];\n    const fgChanged = !equalFg(cell, oldCell);\n    const bgChanged = !equalBg(cell, oldCell);\n    const flagsChanged = !equalFlags(cell, oldCell);\n\n    if (fgChanged || bgChanged || flagsChanged) {\n      if (cell.isAttributeDefault()) {\n        if (!oldCell.isAttributeDefault()) {\n          sgrSeq.push(0);\n        }\n      } else {\n        if (fgChanged) {\n          const color = cell.getFgColor();\n          if (cell.isFgRGB()) { sgrSeq.push(38, 2, (color >>> 16) & 0xFF, (color >>> 8) & 0xFF, color & 0xFF); }\n          else if (cell.isFgPalette()) {\n            if (color >= 16) { sgrSeq.push(38, 5, color); }\n            else { sgrSeq.push(color & 8 ? 90 + (color & 7) : 30 + (color & 7)); }\n          }\n          else { sgrSeq.push(39); }\n        }\n        if (bgChanged) {\n          const color = cell.getBgColor();\n          if (cell.isBgRGB()) { sgrSeq.push(48, 2, (color >>> 16) & 0xFF, (color >>> 8) & 0xFF, color & 0xFF); }\n          else if (cell.isBgPalette()) {\n            if (color >= 16) { sgrSeq.push(48, 5, color); }\n            else { sgrSeq.push(color & 8 ? 100 + (color & 7) : 40 + (color & 7)); }\n          }\n          else { sgrSeq.push(49); }\n        }\n        if (flagsChanged) {\n          if (cell.isInverse() !== oldCell.isInverse()) { sgrSeq.push(cell.isInverse() ? 7 : 27); }\n          if (cell.isBold() !== oldCell.isBold()) { sgrSeq.push(cell.isBold() ? 1 : 22); }\n          if (cell.isUnderline() !== oldCell.isUnderline()) { sgrSeq.push(cell.isUnderline() ? 4 : 24); }\n          if (cell.isBlink() !== oldCell.isBlink()) { sgrSeq.push(cell.isBlink() ? 5 : 25); }\n          if (cell.isInvisible() !== oldCell.isInvisible()) { sgrSeq.push(cell.isInvisible() ? 8 : 28); }\n          if (cell.isItalic() !== oldCell.isItalic()) { sgrSeq.push(cell.isItalic() ? 3 : 23); }\n          if (cell.isDim() !== oldCell.isDim()) { sgrSeq.push(cell.isDim() ? 2 : 22); }\n          if (cell.isStrikethrough() !== oldCell.isStrikethrough()) { sgrSeq.push(cell.isStrikethrough() ? 9 : 29); }\n        }\n      }\n    }\n\n    return sgrSeq;\n  }\n\n  protected _nextCell(cell: IBufferCell, oldCell: IBufferCell, row: number, col: number): void {\n    // a width 0 cell don't need to be count because it is just a placeholder after a CJK character;\n    const isPlaceHolderCell = cell.getWidth() === 0;\n\n    if (isPlaceHolderCell) {\n      return;\n    }\n\n    // this cell don't have content\n    const isEmptyCell = cell.getChars() === '';\n\n    const sgrSeq = this._diffStyle(cell, this._cursorStyle);\n\n    // the empty cell style is only assumed to be changed when background changed, because foreground is always 0.\n    const styleChanged = isEmptyCell ? !equalBg(this._cursorStyle, cell) : sgrSeq.length > 0;\n\n    /**\n     *  handles style change\n     */\n    if (styleChanged) {\n      // before update the style, we need to fill empty cell back\n      if (this._nullCellCount > 0) {\n        // use clear right to set background.\n        if (!equalBg(this._cursorStyle, this._backgroundCell)) {\n          this._currentRow += `\\u001b[${this._nullCellCount}X`;\n        }\n        // use move right to move cursor.\n        this._currentRow += `\\u001b[${this._nullCellCount}C`;\n        this._nullCellCount = 0;\n      }\n\n      this._lastContentCursorRow = this._lastCursorRow = row;\n      this._lastContentCursorCol = this._lastCursorCol = col;\n\n      this._currentRow += `\\u001b[${sgrSeq.join(';')}m`;\n\n      // update the last cursor style\n      const line = this._buffer.getLine(row);\n      if (line !== undefined) {\n        line.getCell(col, this._cursorStyle);\n        this._cursorStyleRow = row;\n        this._cursorStyleCol = col;\n      }\n    }\n\n    /**\n     *  handles actual content\n     */\n    if (isEmptyCell) {\n      this._nullCellCount += cell.getWidth();\n    } else {\n      if (this._nullCellCount > 0) {\n        // we can just assume we have same style with previous one here\n        // because style change is handled by previous stage\n        // use move right when background is empty, use clear right when there is background.\n        if (equalBg(this._cursorStyle, this._backgroundCell)) {\n          this._currentRow += `\\u001b[${this._nullCellCount}C`;\n        } else {\n          this._currentRow += `\\u001b[${this._nullCellCount}X`;\n          this._currentRow += `\\u001b[${this._nullCellCount}C`;\n        }\n        this._nullCellCount = 0;\n      }\n\n      this._currentRow += cell.getChars();\n\n      // update cursor\n      this._lastContentCursorRow = this._lastCursorRow = row;\n      this._lastContentCursorCol = this._lastCursorCol = col + cell.getWidth();\n    }\n  }\n\n  protected _serializeString(): string {\n    let rowEnd = this._allRows.length;\n\n    // the fixup is only required for data without scrollback\n    // because it will always be placed at last line otherwise\n    if (this._buffer.length - this._firstRow <= this._terminal.rows) {\n      rowEnd = this._lastContentCursorRow + 1 - this._firstRow;\n      this._lastCursorCol = this._lastContentCursorCol;\n      this._lastCursorRow = this._lastContentCursorRow;\n    }\n\n    let content = '';\n\n    for (let i = 0; i < rowEnd; i++) {\n      content += this._allRows[i];\n      if (i + 1 < rowEnd) {\n        content += this._allRowSeparators[i];\n      }\n    }\n\n    // restore the cursor\n    const realCursorRow = this._buffer.baseY + this._buffer.cursorY;\n    const realCursorCol = this._buffer.cursorX;\n\n    const cursorMoved = (realCursorRow !== this._lastCursorRow || realCursorCol !== this._lastCursorCol);\n\n    const moveRight = (offset: number): void => {\n      if (offset > 0) {\n        content += `\\u001b[${offset}C`;\n      } else if (offset < 0) {\n        content += `\\u001b[${-offset}D`;\n      }\n    };\n    const moveDown = (offset: number): void => {\n      if (offset > 0) {\n        content += `\\u001b[${offset}B`;\n      } else if (offset < 0) {\n        content += `\\u001b[${-offset}A`;\n      }\n    };\n\n    if (cursorMoved) {\n      moveDown(realCursorRow - this._lastCursorRow);\n      moveRight(realCursorCol - this._lastCursorCol);\n    }\n\n    return content;\n  }\n}\n\nexport class SerializeAddon implements ITerminalAddon {\n  private _terminal: Terminal | undefined;\n\n  constructor() { }\n\n  public activate(terminal: Terminal): void {\n    this._terminal = terminal;\n  }\n\n  private _serializeBuffer(terminal: Terminal, buffer: IBuffer, scrollback?: number): string {\n    const maxRows = buffer.length;\n    const handler = new StringSerializeHandler(buffer, terminal);\n    const correctRows = (scrollback === undefined) ? maxRows : constrain(scrollback + terminal.rows, 0, maxRows);\n    return handler.serialize(maxRows - correctRows, maxRows);\n  }\n\n  private _serializeModes(terminal: Terminal): string {\n    let content = '';\n    const modes = terminal.modes;\n\n    // Default: false\n    if (modes.applicationCursorKeysMode) content += '\\x1b[?1h';\n    if (modes.applicationKeypadMode) content += '\\x1b[?66h';\n    if (modes.bracketedPasteMode) content += '\\x1b[?2004h';\n    if (modes.insertMode) content += '\\x1b[4h';\n    if (modes.originMode) content += '\\x1b[?6h';\n    if (modes.reverseWraparoundMode) content += '\\x1b[?45h';\n    if (modes.sendFocusMode) content += '\\x1b[?1004h';\n\n    // Default: true\n    if (modes.wraparoundMode === false) content += '\\x1b[?7l';\n\n    // Default: 'none'\n    if (modes.mouseTrackingMode !== 'none') {\n      switch (modes.mouseTrackingMode) {\n        case 'x10': content += '\\x1b[?9h'; break;\n        case 'vt200': content += '\\x1b[?1000h'; break;\n        case 'drag': content += '\\x1b[?1002h'; break;\n        case 'any': content += '\\x1b[?1003h'; break;\n      }\n    }\n\n    return content;\n  }\n\n  public serialize(options?: ISerializeOptions): string {\n    // TODO: Add combinedData support\n    if (!this._terminal) {\n      throw new Error('Cannot use addon until it has been loaded');\n    }\n\n    // Normal buffer\n    let content = this._serializeBuffer(this._terminal, this._terminal.buffer.normal, options?.scrollback);\n\n    // Alternate buffer\n    if (!options?.excludeAltBuffer) {\n      if (this._terminal.buffer.active.type === 'alternate') {\n        const alternativeScreenContent = this._serializeBuffer(this._terminal, this._terminal.buffer.alternate, undefined);\n        content += `\\u001b[?1049h\\u001b[H${alternativeScreenContent}`;\n      }\n    }\n\n    // Modes\n    if (!options?.excludeModes) {\n      content += this._serializeModes(this._terminal);\n    }\n\n    return content;\n  }\n\n  public dispose(): void { }\n}\n\n\ninterface ISerializeOptions {\n  scrollback?: number;\n  excludeModes?: boolean;\n  excludeAltBuffer?: boolean;\n}\n"],"names":["root","factory","exports","module","define","amd","this","__webpack_exports__","equalBg","cell1","cell2","getBgColorMode","getBgColor","buffer","_terminal","_rowIndex","_allRows","Array","_allRowSeparators","_currentRow","_nullCellCount","_cursorStyle","_buffer","getNullCell","_cursorStyleRow","_cursorStyleCol","_backgroundCell","_firstRow","_lastCursorRow","_lastCursorCol","_lastContentCursorRow","_lastContentCursorCol","_this","_thisRowLastChar","_thisRowLastSecondChar","_nextRowFirstChar","_beforeSerialize","rows","start","end","_rowEnd","row","isLastRow","rowSeparator","getLine","getCell","currentLine","nextLine","isWrapped","thisRowLastChar","length","thisRowLastSecondChar","nextRowFirstChar","isNextRowFirstCharDoubleWidth","getWidth","isValid","getChars","repeat","_diffStyle","cell","oldCell","sgrSeq","fgChanged","getFgColorMode","getFgColor","bgChanged","flagsChanged","isInverse","isBold","isUnderline","isBlink","isInvisible","isItalic","isDim","isStrikethrough","equalFlags","isAttributeDefault","push","color","isFgRGB","isFgPalette","isBgRGB","isBgPalette","_nextCell","col","isEmptyCell","join","line","undefined","_serializeString","rowEnd","content","i","offset","realCursorRow","baseY","cursorY","realCursorCol","cursorX","moveRight","serialize","startRow","endRow","c","console","warn","_afterSerialize","activate","terminal","_serializeBuffer","scrollback","value","high","maxRows","handler","StringSerializeHandler","correctRows","Math","max","min","_serializeModes","modes","applicationCursorKeysMode","applicationKeypadMode","bracketedPasteMode","insertMode","originMode","reverseWraparoundMode","sendFocusMode","wraparoundMode","mouseTrackingMode","options","Error","normal","excludeAltBuffer","active","type","alternate","excludeModes","dispose","SerializeAddon"],"sourceRoot":""}